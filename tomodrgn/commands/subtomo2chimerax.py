"""
Create a ChimeraX command script (.cxc) to map particles back to their source positions within a tomogram.
Particles may be rendered as ChimeraX spherical markers, as a consensus .mrc volume, or as unique-per-particle volumes generated by tomoDRGN on-the-fly.
Particles may be colored by an array of numeric values per particle, colormapped by a Matplotlib colormap.
Script adapted from relionsubtomo2ChimeraX.py, written by Huy Bui, McGill University, doi: https://doi.org/10.5281/zenodo.6820119.

Example usage: marker mode (places chimerax markers only)

.. code-block:: bash

    python tomodrgn/commands/subtomo2chimerax.py \
        ../m_output_starfiles/10499_22k_box64_angpix6_volumeseries.star \
        --output test_subtomo2chimerax \
        --ind ../27_vae_box96_256x3_128_256x3_128_256x3_b1_gaussian/ind_keep.20981_particles.pkl \
        --mode markers \
        --marker-radius-angstrom 150 \
        --coloring-labels analyze.49/kmeans20/labels.pkl

Example usage: volumes mode (places unique tomoDRGN volumes per particle)

.. code-block:: bash

    python tomodrgn/commands/subtomo2chimerax.py \
        ../m_output_starfiles/10499_22k_box64_angpix6_volumeseries.star \
        -output test_subtomo2chimerax_volumes \
        --ind ../27_vae_box96_256x3_128_256x3_128_256x3_b1_gaussian/ind_keep.20981_particles.pkl \
        --mode volumes \
        --weights weights.49.pkl \
        --config config.pkl \
        --zfile z.49.pkl \
        --downsample 64 \
        --vols-apix 11.5625 \
        --vols-render-level 0.008 \
        --coloring-labels analyze.49/kmeans20/labels.pkl
"""
import argparse
import os
import numpy as np
import pandas as pd
from typing import Literal

from tomodrgn import starfile, utils, mrc, analysis, models

log = utils.log


def add_args(parser: argparse.ArgumentParser | None = None) -> argparse.ArgumentParser:
    if parser is None:
        # this script is called directly; need to create a parser
        parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    else:
        # this script is called from tomodrgn.__main__ entry point, in which case a parser is already created
        pass

    parser.add_argument('starfile',
                        type=os.path.abspath,
                        help='Input volumeseries starfile from subtomogram export; used to specify particle XYZ coordinates and rotational pose.')

    group = parser.add_argument_group('Core arguments')
    group.add_argument('--outdir',
                       type=os.path.abspath,
                       required=True,
                       help='Path to directory to store ouptut script(s) and volume(s).')
    group.add_argument('--mode',
                       choices=('volumes', 'volume', 'markers'),
                       default='markers',
                       help='Choice of particle rendering mode: unique volume per particle, a single consensus volume for all particles, or ChimeraX spherical markers for all particle')
    group.add_argument('--ind',
                       type=os.path.abspath,
                       help='Ind.pkl specified when training tomodrgn model (if applicable). '
                            'Must be specified if either `--zfile`, `--coloring-labels` are specified and the number of values in these pkl files does not match the number of rows in `--starfile`.')
    group.add_argument('--tomoname',
                       type=str,
                       help='Name of a single tomogram in input starfile for which to write mapback script. If blank, default is to prepare scripts and volumes for all tomograms.')
    group.add_argument('--tomo-id-col-override',
                       type=str,
                       help='Name of column in input starfile to filter by --tomoname')
    group.add_argument('--star-angpix-override',
                       type=float,
                       help='Override pixel size of input particle_volumeseries starfile (units Å/px)')

    group = parser.add_argument_group('Volume specification options - generate unique-per-particle tomoDRGN volumes. Required if `--mode volumes`.')
    group.add_argument('--weights',
                       type=os.path.abspath,
                       help='Tomodrgn train_vae model weights to use for generating unique-per-particle volumes.')
    group.add_argument('--config',
                       type=os.path.abspath,
                       help='Tomodrgn train_vae config.pkl file.')
    group.add_argument('--zfile',
                       type=os.path.abspath,
                       help='Tomodrgn train_vae latent embeddings .pkl/.txt file with z-values to decode to volumes.')
    group.add_argument('--flip',
                       action='store_true',
                       help='Optionally flip handedness of output volumes relative to trained model.')
    group.add_argument('--invert',
                       action='store_true',
                       help='Optionally invert contrast of output volumes relative to trained model.')
    group.add_argument('--downsample',
                       type=int,
                       help='Optionally downsample decoded volumes to this box size (pixels). Recommeneded to if model was trained with box size > 128.')
    group.add_argument('--lowpass',
                       type=float,
                       help='Optionally lowpass filter volumes to this resolution in Å.')
    group.add_argument('--skip-vol',
                       action='store_true',
                       help='Skip generation of volumes. Should only be used if volmes have been previously generated by this script. '
                            'Useful for tweaking coloring_labels or colormap. Is not valid if any volume generation parameters or outdir are changed.')

    group = parser.add_argument_group('Volume specification options - single pregenerated volume. Required if `--mode volume`.')
    group.add_argument('--vol-path',
                       type=os.path.abspath,
                       help='Path to single consensus volume to map back at each particle location in tomogram.')

    group = parser.add_argument_group('Volume specification options - ChimeraX spherical markers. Required if `--mode markers`.')
    group.add_argument('--marker-radius-angstrom',
                       type=float,
                       default=100,
                       help='Radius of ChimeraX markers (units: Å).')

    group = parser.add_argument_group('ChimeraX rendering options')
    group.add_argument('--vol-render-level',
                       type=float,
                       default=0.5,
                       help='Isosurface level to render all volumes in ChimeraX')
    group.add_argument('--coloring-labels',
                       type=os.path.abspath,
                       help='Path to a .pkl file containing a unique value for each particle (e.g. kmeans class label, continuous scalar).')
    group.add_argument('--colormap',
                       type=str,
                       help='Matplotlib colormap to apply to --coloring-labels (default = ChimeraX color scheme per label value). '
                            'See https://matplotlib.org/stable/tutorials/colors/colormaps.html (e.g. tab20)')

    return parser


def validate_volume_mode_arguments(args: argparse.Namespace) -> None:
    """
    Check that required inputs are present depending on the volume rendering mode selected.

    :param args: argparse namespace
    :return: None
    """
    if args.mode == 'volumes':
        # need to be able to generate volumes given a trained model, model config, and z values to evaluate
        assert args.weights is not None
        assert args.config is not None
        assert args.zfile is not None
    elif args.mode == 'volume':
        # need to be able to reference volume
        assert args.vol_path is not None
    elif args.mode == 'markers':
        # need to know size to render marker spheres
        assert args.marker_radius_angstrom is not None


def validate_starfile(ptcl_star: starfile.GenericStarfile,
                      ptcl_block_name: str,
                      star_angpix_override: float | None = None,
                      tomo_id_col_override: str | None = None) -> tuple[list[str], list[str], float, str]:
    """
    Identify the star file particles data block and relevant columns within it which specify particle coordinates, angle, pixel size, and tomogram name.

    :param ptcl_star: volume-series star file (each row refers to a unique particle)
    :param ptcl_block_name: name of the star file data block containing per-particle data (e.g. `data_particles`)
    :param star_angpix_override: optional override to pixel size detected in star file (default identified as first column containing `Pixel` substring)
    :param tomo_id_col_override: optional override to column name specifying source tomogram for each particle (default: `_rlnMicrographName`)
    :return: list of column names describing particle rotations, list of column names describing particle coordinates, pixel size of subtomogram coordinates, column name which names source tomogram
    """
    # Identify star file type, and make assumptions about columns names accordingly for required tomogram coordinate, rotational pose, and tomogram name columns
    log('Checking requisite metadata in star file')
    if any(ptcl_star.blocks[ptcl_block_name].columns.str.contains(pat='_rlnCoordinate')):
        # column headers use relion/nextpyp naming
        rots_cols = ['_rlnAngleRot', '_rlnAngleTilt', '_rlnAnglePsi']
        coords_cols = ['_rlnCoordinateX', '_rlnCoordinateY', '_rlnCoordinateZ']
        if tomo_id_col_override is None:
            tomo_id_col_override = '_rlnMicrographName'
    elif any(ptcl_star.blocks[ptcl_block_name].columns.str.contains(pat='_wrpCoordinate')):
        # columns use warp/m naming
        m_coords_cols = [col_name for col_name in ptcl_star.blocks[ptcl_block_name].columns if '_wrpCoordinate' in col_name]
        if len(m_coords_cols) == 3:
            # m temporal sampling == 1
            rots_cols = ['_wrpAngleRot', '_wrpAngleTilt', '_wrpAnglePsi']
            coords_cols = ['_wrpCoordinateX', '_wrpCoordinateY', '_wrpCoordinateZ']
        else:
            # m temporal sampling > 1, have 3*temporal_sampling pose columns
            assert len(m_coords_cols) % 3 == 0
            rots_cols = ['_wrpAngleRot1', '_wrpAngleTilt1', '_wrpAnglePsi1']
            coords_cols = ['_wrpCoordinateX1', '_wrpCoordinateY1', '_wrpCoordinateZ1']
        if tomo_id_col_override is None:
            tomo_id_col_override = '_wrpSourceName'
    else:
        raise RuntimeError(f'Could not identify star file columns containing particle tomogram-level XYZ coordinates from columns: {ptcl_star.blocks[ptcl_block_name].columns}')

    # check that these assumed column names actually exist in the star file
    assert np.all([col in ptcl_star.blocks[ptcl_block_name].columns for col in rots_cols]), f'`{rots_cols} columns not found in starfile `data_` block'
    assert np.all([col in ptcl_star.blocks[ptcl_block_name].columns for col in coords_cols]), f'{coords_cols} columns not found in starfile `data_` block'
    assert tomo_id_col_override in ptcl_star.blocks[ptcl_block_name].columns

    # get the pixel size used in star file to later scale particle coordinates and translations
    if star_angpix_override is None:
        pixel_size_block = ptcl_star.identify_particles_data_block(column_substring='Pixel')
        # possibility that multiple columns contain the substring Pixel, therefore we take the largest pixel size value
        # assumption is that star file might contain original micrograph pixel size + extracted particle (binned) pixel size; we want the latter to correctly position particles
        potential_pixel_columns = [col for col in ptcl_star.blocks[pixel_size_block].columns if 'Pixel' in col]
        if len(potential_pixel_columns) == 1:
            star_angpix = ptcl_star.blocks[pixel_size_block].loc[0, potential_pixel_columns[0]]
        else:
            star_angpix = max(ptcl_star.blocks[pixel_size_block].loc[0, potential_pixel_columns])
    else:
        star_angpix = star_angpix_override

    return rots_cols, coords_cols, star_angpix, tomo_id_col_override


def generate_color_per_particle(ptcl_star: starfile.GenericStarfile,
                                ptcl_block_name: str,
                                labels_path: str | None = None,
                                colormap: str | None = None):
    """
    Calculate an RGBA color for each particle's unique label and store both labels and RGBA tuples in the particles star dataframe.

    :param ptcl_star: volume-series star file (each row refers to a unique particle)
    :param ptcl_block_name: name of the star file data block containing per-particle data (e.g. `data_particles`)
    :param labels_path: path to array of coloring labels from which to derive each particle's color, shape (nptcls, 1)
    :param colormap: matplotlib colormap to translate labels to RGBA tuples. If None, uses ChimeraX color palette (repeated as necessary)
    :return: None
    """
    # load labels per particle
    if labels_path is not None:
        log(f'Loading labels for volume coloring in ChimeraX from {labels_path}')
        labels = utils.load_pkl(labels_path)
        # check number of labels matches total number of particles
        assert len(labels) == len(ptcl_star.blocks[ptcl_block_name])
    else:
        log('No coloring labels were provided; each particle will be assigned a unique random label')
        # assign a unique label per particle
        labels = np.random.choice(a=len(ptcl_star.blocks[ptcl_block_name]),
                                  size=len(ptcl_star.blocks[ptcl_block_name]),
                                  replace=False)

    # ensure labels are dtype int
    if not np.issubdtype(labels.dtype, np.number):
        # assign a unique numeric label for each unique value in labels in order
        mapping = {label: i for i, label in enumerate(set(labels))}
        labels = np.asarray([mapping[label] for label in labels])
    labels = np.rint(labels).astype(int)

    # prepare colormap of per-particle labels
    labels_set = set(labels)
    if colormap is None:
        log('No colormap was provided; using Chimerax color scheme (10 colors) mapped to each class label (with repitition modulo 10 as necessary)')
        cmap = analysis.get_colors_chimerax(len(labels_set))
    else:
        log(f'Using matplotlib color scheme {colormap}')
        cmap = analysis.get_colors_matplotlib(num_colors=len(labels_set),
                                              cmap=colormap)
    labels_rgba = np.array([cmap[label] for label in labels])
    labels_rgba[:, :-1] *= 100  # normalize RGB 0-100 for chimerax, leava alpha 0-1 for chimerax
    labels_rgba = np.around(labels_rgba).astype(int)  # convert to int for chimerax

    # save colors per particle in df
    ptcl_star.blocks[ptcl_block_name]['labels'] = labels
    ptcl_star.blocks[ptcl_block_name]['labels_colors_rgba'] = labels_rgba.tolist()

    return None


def validate_particles_for_rendering(mode: Literal['volumes', 'volume', 'markers'],
                                     vols_dir: str | None = None,
                                     vol_path: str | None = None,
                                     num_ptcls_this_tomo: int | None = None) -> tuple[int, float, list[str]]:
    """
    Validate that particle volumes can be found for volume-based rendering modes.
    Also sets box size and pixel size of particles for mapback.

    :param mode: particle rendering mode for mapback
    :param vols_dir: if mode == 'volumes', should point to directory containing pre-generated volumes for only one tomogram's particles
    :param vol_path: if mode == 'volume', should point to pre-generated single consensus volume
    :param num_ptcls_this_tomo: number of particles to be mapped back in this tomogram. Should match the number of .mrc files found within vols_dir.
    :return: box size of rendered particles (units: px), pixel size of rendered particles (units: Å/px), list of particle volumes to load from disk for mapback
    """
    if mode == 'volumes':
        assert vols_dir is not None
        log(f'Enumerating volumes in {vols_dir}')
        vol_paths = os.listdir(os.path.abspath(vols_dir))
        vol_paths = [os.path.join(vols_dir, vol) for vol in vol_paths if vol.endswith('.mrc')]
        vol_paths.sort(key=lambda x: int(os.path.basename(x).split('_')[-1].split('.mrc')[0]))  # assumes naming format `vol_001.mrc`
        assert len(vol_paths) == num_ptcls_this_tomo, f'Found {len(vol_paths)} volumes in {vols_dir} but expected {num_ptcls_this_tomo} to exist'
        vol, header = mrc.parse_mrc(vol_paths[0])
        vol_box = vol.shape[0]
        vol_angpix = header.get_apix()
    elif mode == 'volume':
        assert vol_path is not None
        assert vol_path.endswith('.mrc')
        vol_paths = [os.path.abspath(vol_path)]
        vol, header = mrc.parse_mrc(vol_paths[0])
        vol_box = vol.shape[0]
        vol_angpix = header.get_apix()
    elif mode == 'markers':
        # required for rotations to be about the origin with rotation approach used below
        vol_box = 1
        vol_angpix = 0
        vol_paths = []
    else:
        raise RuntimeError(f'Unknown mode specified: {mode=}')

    return vol_box, vol_angpix, vol_paths


def write_labels_rgba_by_model(df_one_tomo: pd.DataFrame,
                               outdir_one_tomo: str) -> None:
    """
    Write a text file specifying the mapping between label value - RGBA color - ChimeraX models associated with this label, for the current tomogram'

    :param df_one_tomo: volumeseries star file particles dataframe containing label value and label color metadata for only one tomogram's particles
    :param outdir_one_tomo: output directory to save text file
    :return: None
    """
    # organize models by shared label for ease of selection in chimerax
    labels_set = set(df_one_tomo['labels'].to_numpy())

    # save text mapping of label : rgba specification
    labels_outfile = f'{outdir_one_tomo}/rgba_labels.txt'
    with open(labels_outfile, 'w') as f:
        f.write('Mapping of unique labels : RGBA specification : chimerax models \n\n')
        for i, label in enumerate(labels_set):
            f.write(f'Label : {label} \n')

            rgba = df_one_tomo.loc[df_one_tomo["labels"] == label, "labels_colors_rgba"].values[0]
            f.write(f'RGBa % : {",".join([str(i) for i in rgba])} \n')

            f.write(f'models : {",".join([str(i + 1) for i, l in enumerate(df_one_tomo["labels"].to_numpy()) if l == label])} \n')
            f.write('\n')


def write_mapback_script(df_one_tomo: pd.DataFrame,
                         outdir_one_tomo: str,
                         vol_paths: list[str],
                         rots_cols: list[str],
                         coords_cols: list[str],
                         mode: Literal['volumes', 'volume', 'markers'],
                         vol_boxsize: int,
                         vol_angpix: float,
                         vol_render_level: float,
                         marker_radius_angstrom: float,
                         star_angpix: float) -> None:
    """
    Write a .cxc ChimeraX command file to map back all particles specified in df_one_tomo to source tomogram positions using the specified rendering mode and coloring scheme.

    :param df_one_tomo: volumeseries star file particles dataframe containing metadata for only one tomogram's particles
    :param outdir_one_tomo: output directory to save .cxc file
    :param vol_paths: list of paths to particle volumes to be loaded and mapped back to tomogram positions
    :param rots_cols: list of column headers specifying Euler angles for how to orient particles in tomogram
    :param coords_cols: list of column headers specifying tomogram-level coordinates for how to place particles in tomogram
    :param mode: particle rendering mode for mapback
    :param vol_boxsize: box size of particle volumes (units: px). If mode == 'markers', treated as box size 1 px.
    :param vol_angpix: pixel size of particle volumes (units: Å/px). If mode == 'markers', treated as vol_angpix 0
    :param vol_render_level: isosurface threshold to render volumes in ChimeraX
    :param marker_radius_angstrom: if mode == 'markers', sets ChimeraX marker radius in Ångstrom
    :param star_angpix: pixel size (Å/px) in star file when referencing particle tomogram coordinates or particle translations
    :return: None
    """
    # write commands for each volume
    with open(f'{outdir_one_tomo}/mapback.cxc', 'w') as f:
        for i in range(len(df_one_tomo)):
            # write volume opening command
            if mode == 'volumes':
                # generating each volume in --outdir, so can just use basename
                f.write(f'open "{os.path.basename(vol_paths[i])}"\n')
            elif mode == 'volume':
                # referencing volume at path external to --outdir, so need full path (absolute or relative)
                print(vol_paths)
                f.write(f'open "{vol_paths[0]}"\n')
            elif mode == 'markers':
                f.write(f'marker #{i + 1} position 0,0,0 radius {marker_radius_angstrom}\n')

            # prepare rotation matrix
            eulers_relion = df_one_tomo[rots_cols].iloc[i].to_numpy()
            rot = utils.rot_3d_from_relion(eulers_relion[0], eulers_relion[1], eulers_relion[2])

            # prepare tomogram-scale translations
            coord_px = df_one_tomo[coords_cols].iloc[i].to_numpy()
            coord_ang = coord_px * star_angpix

            # incorporate translations due to refinement
            for j, axis in enumerate(['X', 'Y', 'Z']):
                if f'_rlnOrigin{axis}Angst' in df_one_tomo.columns:
                    shift_ang = df_one_tomo[f'_rlnOrigin{axis}Angst'].iloc[i]
                    coord_ang[j] -= shift_ang
                elif f'_rlnOrigin{axis}' in df_one_tomo.columns:
                    shift = df_one_tomo[f'_rlnOrigin{axis}'].iloc[i]
                    shift_ang = shift * star_angpix
                    coord_ang[j] -= shift_ang
                else:
                    pass

            # incorporate translations due to box rotation
            vol_radius_ang = (np.array([vol_boxsize, vol_boxsize, vol_boxsize]) - 1) / 2 * vol_angpix
            shift_volrot_ang = np.matmul(rot, -vol_radius_ang.transpose())
            coord_ang += shift_volrot_ang

            # write volume positioning command
            chimerax_view_matrix = np.concatenate((rot, coord_ang[:, np.newaxis]), axis=1)
            f.write(f'view matrix mod #{i + 1:d}{"".join([f",{i:.2f}" for i in chimerax_view_matrix.flatten()])}\n')

            # write volume coloring command
            f.write(f'color #{i + 1:d} rgba({"%,".join([str(channel) for channel in df_one_tomo.iloc[i]["labels_colors_rgba"]])})\n')

            f.write('\n')

        if mode == 'volumes' or mode == 'volume':
            f.write('\n')
            f.write(f'volume #{1:d}-{len(df_one_tomo):d} step 1 level {vol_render_level:f}')
            f.write('\n\n')

        f.write('view orient')


def main(args):
    # document all arguments
    log(args)

    # check required arguments are satisfied
    validate_volume_mode_arguments(args)

    # load the star file
    ptcl_star = starfile.GenericStarfile(args.starfile)
    ptcl_block_name = ptcl_star.identify_particles_data_block()

    # validate star file metadata
    rots_cols, coords_cols, star_angpix, tomo_id_col = validate_starfile(ptcl_star=ptcl_star,
                                                                         ptcl_block_name=ptcl_block_name,
                                                                         star_angpix_override=args.star_angpix_override,
                                                                         tomo_id_col_override=args.tomo_id_col_override)

    # filter by indices used during training (if used)
    if args.ind is not None:
        log(f'Filtering starfile by indices {args.ind}')
        ind = utils.load_pkl(args.ind)
        ptcl_star.blocks[ptcl_block_name] = ptcl_star.blocks[ptcl_block_name].iloc[ind]
        ptcl_star.blocks[ptcl_block_name].reset_index(inplace=True)

    # populate colormap, add labels and colors to ind-filtered df
    log(f'Calculating colors for each particle based on colormap {args.colormap} and labels {args.coloring_labels}')
    generate_color_per_particle(ptcl_star=ptcl_star,
                                ptcl_block_name=ptcl_block_name,
                                labels_path=args.coloring_labels,
                                colormap=args.colormap)

    # get list of all tomograms in star file, optionally filtered to tomo of choice
    log('Finding list of all tomograms in star file')
    tomo_names = ptcl_star.blocks[ptcl_block_name][tomo_id_col].unique()
    if args.tomoname:
        log(f'Filtering list of all tomograms to specified tomogram: {args.tomoname}')
        assert args.tomoname in tomo_names
        tomo_names = [args.tomoname]

    # make output directory
    os.makedirs(args.outdir, exist_ok=True)

    # loop over all tomograms
    for tomo_name in tomo_names:
        log(f'Working on tomogram: {tomo_name}')
        df_one_tomo = ptcl_star.blocks[ptcl_block_name][ptcl_star.blocks[ptcl_block_name][tomo_id_col] == tomo_name]
        df_one_tomo = df_one_tomo.reset_index(drop=True)

        # create output dir for this tomogram
        outdir_one_tomo = f'{args.outdir}/tomo_{tomo_name}'
        os.makedirs(outdir_one_tomo, exist_ok=True)

        if args.mode == 'volumes' and not args.skip_vol:
            log('Generating tomoDRGN volumes associated with this tomogram')
            # load z file and assert same length as df
            z_all = utils.load_pkl(args.zfile)
            assert len(z_all) == len(ptcl_star.blocks[ptcl_block_name]), 'Mismatch in number of particles referenced in z file versus in star file. Check that `--ind` is set correctly.'

            # filter z to just this tomogram's inds; write to disk
            z_one_tomo = z_all[df_one_tomo.index.to_numpy()]
            utils.save_pkl(z_one_tomo, f'{outdir_one_tomo}/z_values.pkl')

            # generate all volumes in this tomogram by args and z_values.pkl, store in outdir_one_tomo
            vg = models.VolumeGenerator(config=args.config,
                                        weights_path=args.weights)
            vg.generate_volumes(z=f'{outdir_one_tomo}/z_values.pkl',
                                out_dir=outdir_one_tomo,
                                downsample=args.downsample,
                                lowpass=args.lowpass,
                                flip=args.flip,
                                invert=args.invert,
                                batch_size=1)

        # load the first tomodrgn vol to get boxsize and pixel size, check that all vols can be found
        args.vols_dir = outdir_one_tomo if args.mode == 'volumes' else None
        vol_boxsize, vol_angpix, vol_paths = validate_particles_for_rendering(mode=args.mode,
                                                                              vols_dir=outdir_one_tomo,
                                                                              vol_path=args.vol_path,
                                                                              num_ptcls_this_tomo=len(df_one_tomo))

        # write labels/RGBa in this tomogram
        log('Saving key of unique labels : RGBA specification : ChimeraX models')
        write_labels_rgba_by_model(df_one_tomo=df_one_tomo,
                                   outdir_one_tomo=outdir_one_tomo)

        # write mapback cxc for this tomogram
        log('Saving .cxc file to view subtomogram map-back')
        write_mapback_script(df_one_tomo=df_one_tomo,
                             outdir_one_tomo=outdir_one_tomo,
                             vol_paths=vol_paths,
                             rots_cols=rots_cols,
                             coords_cols=coords_cols,
                             mode=args.mode,
                             vol_boxsize=vol_boxsize,
                             vol_angpix=vol_angpix,
                             vol_render_level=args.vol_render_level,
                             marker_radius_angstrom=args.marker_radius_angstrom,
                             star_angpix=star_angpix)


if __name__ == '__main__':
    main(add_args().parse_args())
